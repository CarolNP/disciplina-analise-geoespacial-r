<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introdução à análise geoespacial com R    </title>
    <meta charset="utf-8" />
    <meta name="author" content="Maurício H. Vancine   Milton C. Ribeiro" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis-fonts.css" rel="stylesheet" />
    <link href="libs/font-awesome/css/fontawesome-all.min.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Introdução à análise geoespacial com R <br><br><br>
## 3 Estrutura e manipulação de dados na linguagem R <br><br><br>
### Maurício H. Vancine <br> Milton C. Ribeiro
### 20/10/2020

---




class: clear
background-image: url(img/r_data_structures02.png)
background-size: 700px

---

background-image: url(img/r_data_structures01.png)
background-size: 400px
background-position: 85% 90%

# 3 Estrutura e manipulação de dados

## Conteúdo
1. Atributo dos objetos
1. Modo dos objetos (numeric, character e logical)
1. Estrutura dos objetos (vector, factor, matrix, data frame e list)
1. Manipulação de dados unidimensionais
1. Manipulação de dados bidimensionais
1. Valores faltantes e especiais
1. Diretório de trabalho
1. Importar dados
1. Conferir e manejar dados importados
1. Exportar dados

---

# 3 Estrutura e manipulação de dados

## Script

&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;

## .center[`03_script_intro_geocomp_r.R`]

---

# 3.1 Atributos dos objetos

## Atribuição

&lt;br&gt;&lt;br&gt;

## **palavra &lt;- dados**

--

&lt;br&gt;&lt;br&gt;


```r
## atribuicao - simbolo (&lt;-)
obj_10 &lt;- 10 
obj_10
```

---

# 3.1 Atributos dos objetos

## Atributos dos objetos no R

### Objetos possuem **três características**:

&lt;br&gt;

--

### 1. **Nome**: palavra que o R reconhece os dados atribuídos

--

### 2. **Conteúdo**: dados em si

--

### 3. **Atributos**: modos (*natureza*) e estruturas (*organização*)

---

background-image: url(img/code_modes.png)
background-size: 70%
background-position: 50% 90%

# 3.2 Modo dos objetos

## Modos (*natureza*): numeric, character e logical

### **Natureza** dos **elementos** que compõem os objetos

---

# 3.2 Modo dos objetos

## **1. Numeric**: números inteiros ou decimais


```r
# numeric
obj_num &lt;- 1
obj_num
```
--

```r
# mode
mode(obj_num)
```

---

# 3.2 Modo dos objetos

## **2. Character**: texto ou caracteres


```r
# character
obj_cha &lt;- "a" # atencao para as aspas
obj_cha
```
--

```r
# mode
mode(obj_cha)
```

---

# 3.2 Modo dos objetos

## **3. Logical**: indica a ocorrência ou não de um evento (TRUE ou FALSE - booleano)


```r
# logical
obj_log &lt;- TRUE # maiusculas e sem aspas
obj_log
```
--

```r
# mode
mode(obj_log)
```

---

# 3.2 Modo dos objetos

## Resumindo:

### A **natureza** dos **elementos** irá definir os **modos** dos objetos

--

&lt;br&gt;&lt;br&gt;

## Modos (*natureza*) são **três**: 

### numeric (**número**): *1*
### character (**texto**): *"a"*, *"2500"*, *"amostra_01"*
### logical (**lógico**): *TRUE* ou *FALSE*

---

# 3.3 Estrutura dos objetos

## Estruturas (*organização*): vector, factor, matrix, array, data frame e list

--

### Organização (**modos** e **dimensionalidade**) dos elementos dos objetos

--

background-image: url(img/code_data_structures01.png)
background-size: 450px
background-position: 50% 90%

---

background-image: url(img/code_data_structures02.png)
background-size: 650px
background-position: 50% 50%

# 3.3 Estrutura dos objetos

---

background-image: url(img/code_data_structures03.png)
background-size: 800px
background-position: 50% 50%

# 3.3 Estrutura dos objetos

---

# 3.3 Estrutura dos objetos

## **1. Vector**: homogêneo (*um modo*) e unidimensional (*uma dimensão*)

### O **vetor** representa medidas de uma **variável quantitativa** (discretas ou contínuas) ou **descrição** (informações em texto)

--

### Ex.: medidas tomadas em campo ao longo de uma amostragem de 5 meses

1. Amostragens: {"amostra_01", "amostra_02", "amostra_03", "amostra_04", "amostra_05"}
2. Temperatura: {15, 18, 20, 22, 18}
3. Abertura do dossel: {0.37, 0.45, 0.65, 0.75, 0.40
4. Abundância de uma espécie: {6, 3, 0, 0, 2}

---

background-image: url(img/general_vector_math.jpg)
background-size: 500px
background-position: 50% 70%

# 3.3 Estrutura dos objetos

## Não me refiro exatamente ao vetor da matemática

---

background-image: url(img/code_vector_types01.png)
background-size: 800px
background-position: 50% 50%

# 3.3 Estrutura dos objetos

## Sequência de elementos

---

background-image: url(img/code_vector_summary_tree.png)
background-size: 550px
background-position: 50% 70%

# 3.3 Estrutura dos objetos

## Tipos

---

# 3.3 Estrutura dos objetos

### Há diversas formas de se criar um **vetor**:

--

### 1. Concatenar elementos

```r
# concatenar elementos numericos
temp &lt;- c(15, 18, 20, 22, 18)
temp
```
&lt;br&gt;
--

```r
# concatenar elementos de texto
amos &lt;- c("amostra_01", "amostra_02", "amostra_03", "amostra_04")
amos
```

---

# 3.3 Estrutura dos objetos

### Há diversas formas de se criar um **vetor**:

### 2. Sequência

```r
# sequencia unitaria (x1:x2)
se &lt;- 1:10
se
```
&lt;br&gt;
--

```r
# sequencia com diferentes espacamentos 
se_e &lt;- seq(from = 0, to = 100, by = 10) 
se_e
```

---

# 3.3 Estrutura dos objetos

### Há diversas formas de se criar um **vetor**:

### 3. Repetição

```r
# repeticao
# rep(x, times) # repete x tantas vezes
rep_times &lt;- rep(x = c(1, 2), times = 5)
rep_times
```
&lt;br&gt;
--

```r
# rep(x, each) # retete x tantas vezes de cada
rep_each &lt;- rep(x = c("a", "b"), each = 5)
rep_each
```

---

# 3.3 Estrutura dos objetos

### Há diversas formas de se criar um **vetor**:

### 4. "Colar" palavras com uma sequência numérica


```r
# palavra e sequencia numerica - sem separacao definida (" ")
am1 &lt;- paste("amostra", 1:5)
am1
```
&lt;br&gt;
--

```r
# palavra e sequencia numerica - separacao por "_0"
am2 &lt;- paste("amostra", 1:5, sep = "_0")
am2
```

---

# 3.3 Estrutura dos objetos

### Há diversas formas de se criar um **vetor**:

### 5. Amostrando aleatoriamente elementos


```r
# amostragem aleatória - sem reposição
sa_sem_rep &lt;- sample(1:100, 10)
sa_sem_rep
```

--


```r
# amostragem aleatória - com reposição
sa_com_rep &lt;- sample(1:10, 100, replace = TRUE)
sa_com_rep
```

---

class: inverse, middle, center
# Exercícios

---

# Exercício 05

## Vector
### Escolham números para jogar na mega-sena
### Lembrando: são 6 valores de 1 a 60 e atribuam a um objeto



---

# Exercício 05

## Resposta


```r
# solucao
mega_num &lt;- sample(1:60, 6, replace = FALSE)
mega_num
```

---

class: inverse, center, middle

# E se eu criar um vetor com elementos de **modos diferentes**?

---

# 3.3 Estrutura dos objetos

## Vetor com elementos de **modos diferentes**:

--

&lt;br&gt;


```r
ve &lt;- c(1, "a", 3)
ve
```
--
&lt;br&gt;

```r
ve &lt;- c(1, "a", TRUE)
ve
```

---

# Coerção

### Mudança do **modo** dos elementos para um **mesmo modo**

### Essa mudança segue essa ordem:

&lt;br&gt;

#### .center[`DOMINANTE` **character** &gt;&gt; **numeric** &gt;&gt; **logical** `RECESSIVO`]

--

background-image: url(img/code_modes.png)
background-size: 60%
background-position: 50% 100%

---

# Conversão

## Podemos **forçar** um vetor a ter um **modo específico**

--

### Ideia semelhante: mudar o **tipo da célula** numa planilha eletrônica

--

### Conversão

```r
# funcoes
as.character()
as.integer()
as.numeric()
as.logical()
```

---

# 3.3 Estrutura dos objetos

## **2. Factor**: homogêneo (*um modo* - sempre *numeric*), unidimensional (*uma dimensão*) e possui ainda **levels** (níveis)

--

### O **factor** representa medidas de uma **variável qualitativa**, podendo ser **nominal** ou **ordinal**

--

### Ex.: medidas tomadas em campo ao longo de uma amostragem de 6 meses
1. Amostragens: {"amostra_01", "amostra_02", "amostra_03", "amostra_04", "amostra_05"}
2. Tipo de floresta: {fechada, fechada, aberta, aberta, aberta}
3. Abundância de uma espécie: {alta, media, baixa, baixa, media}

---

background-image: url(img/code_factor.png)
background-size: 70%
background-position: 50% 75%

# 3.3 Estrutura dos objetos

## **2. Factor**: homogêneo (*um modo* - sempre *numeric*), unidimensional (*uma dimensão*) e possui ainda **levels** (níveis)

---

# 3.3 Estrutura dos objetos

## **2. Factor nominal**: variáveis nominais


```r
fa_no &lt;- factor(x = c("fechada", "fechada", "aberta", "aberta", "aberta"),
                levels = c("aberta", "fechada"))
fa_no
```
--

```r
levels(fa_no)
```
---

# 3.3 Estrutura dos objetos

## **2. Factor ordinal**: variáveis ordinais

```r
fa_or &lt;- factor(x = c("alta", "media", "baixa", "baixa", "media"),
                levels = c("baixa", "media", "alta"), ordered = TRUE)
fa_or
```
--

```r
levels(fa_or)
```

---

# 3.3 Estrutura dos objetos

## **2. Factor**: conversão

--

### Criar um vetor **character**

```r
ve_ch &lt;- c("alta", "media", "baixa", "baixa", "media")
ve_ch
```
--

```r
mode(ve_ch)
```
--

```r
class(ve_ch)
```

---

# 3.3 Estrutura dos objetos

## **2. Factor**: conversão

### Forçar a ser **factor nominal**

```r
fa_no &lt;- as.factor(ve_ch)
fa_no
```
--

```r
levels(fa_no)
```
--

```r
class(fa_no)
```

---

class: clear, inverse, middle, center
# Exercícios

---

# Exercício 06

## Factor
### Criem um fator chamado "tr", com dois níveis ("cont" e "trat") para descrever 100 locais de amostragem, 50 de cada tratamento. O fator deve ser dessa forma:

`cont, cont, cont, ...., cont, trat, trat, ...., trat`



---

# Exercício 06

## Resposta

```r
# solucao 1
ch &lt;- rep(c("cont", "trat"), each = 50)
ch

tr &lt;- as.factor(ch)
tr
```

--


```r
# solucao 2
tr &lt;- as.factor(rep(c("cont", "trat"), each = 50))
tr
```

---

background-image: url(img/code_data_structures03.png)
background-size: 800px
background-position: 50% 50%

# 3.3 Estrutura dos objetos

## **3. Matrix**

---

# 3.3 Estrutura dos objetos

## **3. Matrix**: homogêneo (*um modo*) e bidimensional (*duas dimensão*)

--

### A **matrix** representa os dados no formato de **tabela**, com **linhas** e **colunas**

--

### As **linhas** representam **unidades amostrais** (locais, transectos, parcelas) e as **coluncas** representam **variáveis quantitativas** (discretas ou contínuas) ou **descrições** (informações em texto)

---

background-image: url(img/code_matrix.png)
background-size: 630px
background-position: 130% 200%

# 3.3 Estrutura dos objetos

## **3. Matrix**: homogêneo (*um modo*) e bidimensional (*duas dimensão*)

### Ex.: espécies amostradas 5 locais

---

class: inverse, center, middle

# Esse formato lembra algo?

---

background-image: url(img/general_eletronic_sheet.png)
background-size: 700px
background-position: 50% 60%

# 3.3 Estrutura dos objetos

## **3. Matrix**: planilhas eletrônicas

---

class: clear, inverse
background-image: url(img/gif_mind_blowing01.gif)
background-size: 700px

---

# 3.3 Estrutura dos objetos

## Há **duas formas** de se construir uma **matrix** no R:

### 1 Dispondo elementos

`matrix`: dispõem um vetor em um certo número de linhas e colunas


```r
# matriz - funcao matrix
# vetor
ve &lt;- 1:12
```
--

```r
# matrix - preenchimento por linhas - horizontal
ma_row &lt;- matrix(data = ve, nrow = 4, ncol = 3, byrow = TRUE)
ma_row
```

---

# 3.3 Estrutura dos objetos

## Há **duas formas** de se construir uma **matrix** no R:

### 1 Dispondo elementos

`matrix`: dispõem um vetor em um certo número de linhas e colunas


```r
# matriz - funcao matrix
# vetor
ve &lt;- 1:12
```


```r
# matrix - preenchimento por colunas - vertical
ma_col &lt;- matrix(data = ve, nrow = 4, ncol = 3, byrow = FALSE)
ma_col
```

---

# 3.3 Estrutura dos objetos

## Há **duas formas** de se construir uma **matrix** no R:

###  2 Combinando vetores
`rbind`: combina vetores por linha, i.e., vetor embaixo do outro

`cbind`: combina vetores por coluna, i.e., vetor ao lado do outro


```r
# criar dois vetores
vec_1 &lt;- c(1, 2, 3)
vec_2 &lt;- c(4, 5, 6)
```
--

```r
# combinar por linhas - vertical - um embaixo do outro
ma_rbind &lt;- rbind(vec_1, vec_2)
ma_rbind
```

---

# 3.3 Estrutura dos objetos

## Há **duas formas** de se construir uma **matrix** no R:

###  2 Combinando vetores
`rbind`: combina vetores por linha, i.e., vetor embaixo do outro

`cbind`: combina vetores por coluna, i.e., vetor ao lado do outro


```r
# criar dois vetores
vec_1 &lt;- c(1, 2, 3)
vec_2 &lt;- c(4, 5, 6)
```


```r
# combinar por colunas - horizontal - um ao lado do outro
ma_cbind &lt;- cbind(vec_1, vec_2)
ma_cbind
```

---

class: inverse, middle, center
# Exercícios

---

# Exercício 07

## Matrix

### Criem uma matriz chamada "ma", resultante da disposição de um vetor composto por 10000 valores aleatórios entre 0 e 10. A matriz deve conter 100 linhas e ser disposta por colunas




---

# Exercício 07

## Resposta


```r
# solucao
ma &lt;- matrix(sample(0:10, 10000, rep = TRUE), nrow = 100, byrow = FALSE)
ma
```

---

background-image: url(img/code_data_structures03.png)
background-size: 800px
background-position: 50% 50%

# 3.3 Estrutura dos objetos

## **4. Array**

---

# 3.3 Estrutura dos objetos

## **4. Array**: homogêneo (*um modo*) e multidimensional (*mais que duas dimensões*)

--

### O **array** representa combinação de **tabelas**, com **linhas**, **colunas** e **dimensões**

--

background-image: url(img/code_array.png)
background-size: 480px
background-position: 90% 100%

---

class: clear, inverse
background-image: url(img/gif_jim_carrey.gif)
background-size: 700px

---

# 3.3 Estrutura dos objetos

## Há **uma forma** de se construir um **array** no R:

### 1 Dispondo elementos

`array`: dispõem um vetor em um certo número de linhas, colunas e dimensões....


```r
# vetor
ve &lt;- 1:8
ve
```

---

# 3.3 Estrutura dos objetos

## Há **uma forma** de se construir um **array** no R:

### 1 Dispondo elementos

`array`: dispõem um vetor em um certo número de linhas, colunas e dimensões....

```r
ar &lt;- array(data = ve, dim = c(2, 2, 2))
ar
```

---

background-image: url(img/code_data_array.png)
background-size: 700px
background-position: 50% 120%

# 3.3 Estrutura dos objetos

## Até o momento vimos **estruturas homogêneas**

---

background-image: url(img/code_data_same.png)
background-size: 700px
background-position: 50% 120%

# 3.3 Estrutura dos objetos

## Agora veremos as **estruturas heterogêneos**

---

background-image: url(img/code_data_structures03.png)
background-size: 800px
background-position: 50% 50%

# 3.3 Estrutura dos objetos

## **5. Data frame**

---

# 3.3 Estrutura dos objetos

## **5. Data frame**: heterogêneo (*mais de um modo*) e bidimensional (*duas dimensões*)

--

### O **data frame** representa dados no formato de **tabela**, com **linhas** e **colunas**

--

### As **linhas** representam **unidades amostrais** (locais, transectos, parcelas) e as **colunas** representam **descrições** (informações em texto), **variáveis quantitativas** (discretas ou contínuas) e/ou **variáveis qualitativas** (nominais ou ordinais)

---

background-image: url(img/code_data_structures03.png)
background-size: 800px
background-position: 50% 60%

# 3.3 Estrutura dos objetos

## **5. Data frame**: heterogêneo (*mais de um modo*) e bidimensional (*duas dimensões*)

---

class: inverse, center, middle

# Esse formato também lembra algo?

---

background-image: url(img/general_eletronic_sheet.png)
background-size: 700px
background-position: 50% 60%

# 3.3 Estrutura dos objetos

## **5. Data frame**: planilhas eletrônicas

---

class: inverse, center, middle

# Esse é justamente o formato de entrada dos dados de planilhas eletrônicas!

---

class: clear, inverse
background-image: url(img/gif_mind_blowing02.gif)
background-size: 700px

---

# 3.3 Estrutura dos objetos

## Há **uma forma** de se construir um **data frame** no R:

### 1 Combinando vetores horizontalmente

`data.frame`: combina vetores horizontalmente, um ao lado do outro. Semelhante à função `cbind`


```r
# criar três vetores
vec_ch &lt;- c("sp1", "sp2", "sp3")
vec_nu &lt;- c(4, 5, 6)
vec_fa &lt;- factor(c("campo", "floresta", "floresta"))
```
--

```r
# data.frame - combinar por colunas - horizontal - um ao lado do outro
df &lt;- data.frame(vec_ch, vec_nu, vec_fa)
df
```

---

# 3.3 Estrutura dos objetos

## Há **uma forma** de se construir um **data frame** no R:

### 1 Combinando vetores horizontalmente

### Também podemos informar o nome das colunas

--

```r
# data.frame
df &lt;- data.frame(especies = vec_ch, 
                 abundancia = vec_nu, 
                 vegetacao = vec_fa)
df
```

---

# 3.3 Estrutura dos objetos

## **data frame** vs **cbind**

### Criação dos vetores

```r
## vetores
pa &lt;- paste("parcela", 1:4, sep = "_")
pa
```
--

```r
pe &lt;- sample(0:1, 4, rep = TRUE)
pe
```
--

```r
tr &lt;- factor(rep(c("trat", "cont"), each = 2))
tr
```

---

# 3.3 Estrutura dos objetos

## Qual a diferença?


```r
# uniao de vetores
df &lt;- data.frame(pa, pe, tr)
df
```
--

```r
str(df)
```

---

# 3.3 Estrutura dos objetos

## Qual a diferença?


```r
# uniao de vetores
df_c &lt;- cbind(pa, pe, tr)
df_c
```
--

```r
str(df_c)
```

---

class: inverse, middle, center
# Exercícios

---

# Exercício 08

## Data frame

### Criem um data frame "df", resultante da composição desses vetores: 
`id: 1:50`

`sp: sp01, sp02, ..., sp49, sp50`

`ab: 50 valores aleatórios entre 0 a 5`



---

# Exercício 08

## Resposta


```r
# solucao
id &lt;- 1:50
id

sp &lt;- c(paste("sp", 1:9, sep = "0"), paste("sp", 10:50, sep = ""))
sp

ab &lt;- sample(0:5, 50, replace = TRUE)
ab

df &lt;- data.frame(id, sp, ab)
df
```

---

background-image: url(img/code_data_structures03.png)
background-size: 800px
background-position: 50% 50%

# 3.3 Estrutura dos objetos

## **6. List**

---

# 3.3 Estrutura dos objetos

## **6. List**: heterogêneo (*mais de um modo*) e unidimensional (*uma dimensão*)

--

### Tipo **especial de vetor** que aceita **objetos** como **elementos**

--

### Estrutura de dados utilizado para **agrupar objetos**

--

### É a **saída** de muitas funções que fazem **análises estatísticas**

--

background-image: url(img/code_list.png)
background-size: 300px
background-position: 50% 95%

---

# 3.3 Estrutura dos objetos

## **6. List**: heterogêneo (*mais de um modo*) e unidimensional (*uma dimensão*)


```r
li &lt;- list(rep(1, 20), # vector
           factor(1, 1), # factor
           cbind(c(1, 2), c(1, 2))) # matrix
li
```

---

# 3.3 Estrutura dos objetos

## **6. List**: heterogêneo (*mais de um modo*) e unidimensional (*uma dimensão*)

### Também podemos **nomear** os elementos


```r
li &lt;- list(vector = rep(1, 20), # vector
           factor = factor(1, 1), # factor
           matrix = cbind(c(1, 2), c(1, 2))) # matrix
li
```

---

class: inverse, center, middle

# Dúvidas?

---

class: inverse, center, middle

# Bora manejar isso tudo?

---

class: clear
background-image: url(img/r_data_manipulation.png)
background-size: 700px

---

# 3.4 Manipulação de dados (1D)

## Vetor e fator

### **1. Indexação []**: acessa elementos de vetores e fatores

```r
## indexacao []
# vetor
se &lt;- seq(0, 2, .05)
se

# fixar a amostragem
set.seed(42)
ve &lt;- sample(se, 10)
ve
```

---

# 3.4 Manipulação de dados (1D)

## Vetor e fator

### **1. Indexação []**

### Selecionar elementos

```r
# seleciona o quinto elemento
ve[5]
```
--

```r
# seleciona os elementos de 1 a 5
ve[1:5] 
```
--

```r
# seleciona os elementos 1 e 10 e atribui
ve_sel &lt;- ve[c(1, 10)]
ve_sel
```

---

# 3.4 Manipulação de dados (1D)

## Vetor e fator

### **1. Indexação []**

### Retirar elementos

```r
# retira o decimo elemento
ve[-10]
```
--

```r
# retira os elementos 2 a 9
ve[-(2:9)]
```
--

```r
# retira os elementos 5 e 10 e atribui
ve_sub &lt;- ve[-c(5, 10)]
ve_sub
```

---

# 3.4 Manipulação de dados (1D)

## Vetor e fator

### **2 Seleção condicional**: selecionar elementos por condições 

```r
# dois vetores
foo &lt;- 42
bar &lt;- 23
```
--

```r
# operadores relacionais - saidas booleanas (TRUE ou FALSE)
foo == bar # igualdade
foo != bar # diferenca 
foo &gt; bar # maior
foo &gt;= bar # maior ou igual
foo &lt; bar # menor
foo &lt;= bar # menor ou igual
```

---

# 3.4 Manipulação de dados (1D)

## Vetor e fator

### **2 Seleção condicional**

```r
# quais valores sao maiores que 1?
ve &gt; 1
```

--


```r
# valores acima de 1
ve[ve &gt; 1] 
```

--


```r
# atribuir valores maiores que 1
ve_maior1 &lt;- ve[ve &gt; 1]
ve_maior1
```

---

# 3.4 Manipulação de dados (1D)

## Vetor e fator

### **3 Funções de manipulação**: *max*, *min*, *range*, *length*, *sort* e *round*

```r
# maximo
max(ve)
```

--


```r
# minimo
min(ve)
```

---

# 3.4 Manipulação de dados (1D)

## Vetor e fator

### **3 Funções de manipulação**: *max*, *min*, *range*, *length*, *sort* e *round*

```r
# amplitude
range(ve)
```

--


```r
# comprimento
length(ve)
```

---

# 3.4 Manipulação de dados (1D)

## Vetor e fator

### **3 Funções de manipulação**: *max*, *min*, *range*, *length*, *sort* e *round*

```r
# ordenar crescente
sort(ve)
```

--


```r
# ordenar decrescente
sort(ve, dec = TRUE)
```

---

# 3.4 Manipulação de dados (1D)

## Vetor e fator

### **3 Funções de manipulação**: *max*, *min*, *range*, *length*, *sort* e *round*

```r
# arredondamento
ve
```

--


```r
# arredondamento
round(ve, digits = 1)
```

--


```r
# arredondamento
round(ve, digits = 0)
```

---

# 3.4 Manipulação de dados (1D)

## Vetor e fator

### **3 Funções de manipulação**: *any()*, *all()* e *which()*

```r
# algum?
any(ve &gt; 1)
```

--


```r
# todos?
all(ve &gt; 1)
```

--


```r
# qual(is)?
which(ve &gt; 1)
```

---

# 3.4 Manipulação de dados (1D)

## Vetor e fator

### **3 Funções de manipulação**: *subset* e *ifelse*

```r
# subconjunto
subset(ve, ve &gt; 1)
```

--


```r
# condicao para uma operacao
ifelse(ve &gt; 1, 1, 0)
```

---

# 3.4 Manipulação de dados (1D)

## Listas

### **1. Indexação []**: acessa elementos de listas

```r
## indexacao []
# lista
li &lt;- list(elem1 = 1, elem2 = 2, elem3 = 3)
li
```

---

# 3.4 Manipulação de dados (1D)

## Listas

### **1. Indexação []**: acessa elementos de listas

### Selecionar elementos

```r
# acessar o primeiro elemento
li[1]
```
--

```r
# acessar o primeiro e o terceiro elementos e atribuir
li2 &lt;- li[c(1, 3)]
li2
```

---

# 3.4 Manipulação de dados (1D)

## Listas

### **1. Indexação []**: acessa elementos de listas

### Retirar elementos

```r
# retirar o primeiro elemento
li[-1]
```
--

```r
# retirar o segundo elemento e atribuir
li_13 &lt;- li[-2]
li_13
```

---

# 3.4 Manipulação de dados (1D)

## Listas

### **2. Indexação $**: acessa elementos pelo nome

### Selecionar elementos

```r
# acessar o primeiro elemento
li$elem1
```
--

```r
# acessar o primeiro e o terceiro elementos e atribuir
li1 &lt;- li$elem1
li1
```

---

# 3.4 Manipulação de dados (1D)

## Listas

### **3. Funções**: *length* e *names*

```r
# comprimento
length(li)
```
--

```r
# names
names(li)
```

---

background-image: url(img/code_df_manipulation02.png)
background-size: 700px
background-position: 50% 70%

# 3.5 Manipulação de dados (2D)

## Matrizes e Data Frames

---

# 3.5 Manipulação de dados (2D)

## Matrizes e Data Frames

### **1 Indexação []**

```r
# matriz
ma &lt;- matrix(1:12, 4, 3)
ma 
```

---

background-image: url(img/code_df_manipulation01.png)
background-size: 400px
background-position: 50% 50%

# 3.5 Manipulação de dados (2D)

## Matrizes e Data Frames

### **1 Indexação []**

---

# 3.5 Manipulação de dados (2D)

## Matrizes e Data Frames

### **1 Indexação []**

```r
ma[3, ] # linha 3
```
--

```r
ma[, 2] # coluna 2
```
--

```r
ma[1, 2] # elemento da linha 1 e coluna 2
```
--

```r
ma[1, 1:2] # elementos da linha 1 e coluna 1 e 2
```

---

# 3.5 Manipulação de dados (2D)

## Matrizes e Data Frames

### **1 Indexação []**

```r
ma[1, c(1, 3)] # elementos da linha 1 e coluna 1 e 3
```
--

```r
ma_sel &lt;- ma[1, c(1, 3)]
ma_sel
```

---

background-image: url(img/code_df_manipulation02.png)
background-size: 700px
background-position: 50% 75%

# 3.5 Manipulação de dados (2D)

## Matrizes e Data Frames

### **1 Indexação []**: resumindo

---

# 3.5 Manipulação de dados (2D)

## Data Frames

### **1 Indexação $**

```r
# criar tres vetores
sp &lt;- paste("sp", 1:10, sep = "")
abu &lt;- 1:10
flo &lt;- factor(rep(c("campo", "floresta"), each = 5))
```
--

```r
# data frame
df &lt;- data.frame(sp, abu, flo)
df
```

---

# 3.5 Manipulação de dados (2D)

## Data Frames

### **1 Indexação $**

```r
# $ funciona apenas para data frame 
df$sp 
```
--

```r
df$abu
```
--

```r
df$flo
```

---

# 3.5 Manipulação de dados (2D)

## Data Frames

### **1 Indexação $**

```r
length(df$abu)
max(df$abu)
min(df$abu)
range(df$abu)
```

---

# 3.5 Manipulação de dados (2D)

## Data Frames

### **1 Indexação $ e mudanças de colunas**

```r
mode(df$abu)
```
--

```r
# converter colunas
df$abu &lt;- as.character(df$abu)
```
--

```r
df$abu
mode(df$abu)
```

---

# 3.5 Manipulação de dados (2D)

## Data Frames

### **1 Indexação $ e mudanças de colunas**

```r
df$abu &lt;- as.numeric(df$abu)
```
--

```r
df$abu
mode(df$abu)
```

---

# 3.5 Manipulação de dados (2D)

## Data Frames

### **1 Indexação $ e adicionar uma coluna**

```r
set.seed(42)
df$abu2 &lt;- sample(0:1, nrow(df), rep = TRUE)
```
--

```r
df$abu2
```
--

```r
df
```

---

# 3.5 Manipulação de dados (2D)

## Data Frames

### **2 Seleção condicional**

### Selecionar linhas = filtro do planilha eletrônica

```r
# selecionar linhas de uma matriz ou data frame 
df[df$abu &gt; 4, ]
```

---

# 3.5 Manipulação de dados (2D)

## Data Frames

### **2 Seleção condicional**

### Selecionar linhas = filtro do planilha eletrônica

```r
# selecionar linhas de uma matriz ou data frame 
df[df$abu2 == 0, ]
```

---

# 3.5 Manipulação de dados (2D)

## Data Frames

### **2 Seleção condicional**

### Selecionar linhas = filtro do planilha eletrônica

```r
# selecionar linhas de uma matriz ou data frame 
df[df$flo == "floresta", ]
```

---

# 3.5 Manipulação de dados (2D)

## Matrizes e Data Frames

### **3 Funções de visualização e manipulação**

**head()**: mostra as primeiras 6 linhas &lt;br&gt;
**tail()**: mostra as últimas 6 linhas &lt;br&gt;
**nrow()**: mostra o número de linhas &lt;br&gt;
**ncol()**: mostra o número de colunas &lt;br&gt;
**dim()**: mostra o número de linhas e de colunas &lt;br&gt;
**rownames()**: mostra os nomes das linhas (locais) &lt;br&gt;
**colnames()**: mostra os nomes das colunas (variáveis) &lt;br&gt;
**str()**: mostra as classes de cada coluna (estrutura) &lt;br&gt;
**summary()**: mostra um resumo dos valores de cada coluna &lt;br&gt;
**rowSums()**: calcula a soma das linhas (horizontal) &lt;br&gt;
**colSums()**: calcula a soma das colunas (vertical) &lt;br&gt;
**rowMeans()**: calcula a média das linhas (horizontal) &lt;br&gt;
**colMeans()**: calcula a média das colunas (vertical)

---

# 3.6 Valores faltantes e especiais

## São **valores reservados** que representam *dados faltantes*, *indefinições matemáticas*, *infinitos* e *objetos nulos*

&lt;br&gt;&lt;br&gt;

### **1 NA (Not Available)**

### **2 NaN (Not a Number)**

### **3 Inf (Infinito)**

### **4 NULL**

---

# 3.6 Valores faltantes e especiais

## **1 NA (Not Available)**

### Significa dado faltante/indisponível

### **NA** deve ser maiúsculo


```r
# na - not available
foo_na &lt;- NA
foo_na
```

---

# 3.6 Valores faltantes e especiais

## **1 NA (Not Available)**

### Criar um data frame com NA

```r
# data frame
df &lt;- data.frame(var1 = c(1, 4, 2, NA), var2 = c(1, 4, 5, 2))
df
```

---

# 3.6 Valores faltantes e especiais

## **1 NA (Not Available)**

### Função para verificar a **presença/ausência** de NA's

```r
is.na(df)
```

--

### Função para verificar a **presença de algum** NA's

```r
any(is.na(df))
```

---

# 3.6 Valores faltantes e especiais

## **1 NA (Not Available)**

### Vamos retirar as linhas que possuem NA's

```r
df_sem_na &lt;- na.omit(df)
df_sem_na
```
--

```r
nrow(df)
nrow(df_sem_na)
```

---

# 3.6 Valores faltantes e especiais

## **1 NA (Not Available)**

### Vamos substituir os NA's por 0

```r
# substituir na por 0
df[is.na(df)] &lt;- 0
df
```

---

# 3.6 Valores faltantes e especiais

## **2 NaN (Not a Number)**

### Representa indefinições matemáticas como 0/0 e log(-1)


```r
# nan - not a number
0/0

log(-1)
```

---

# 3.6 Valores faltantes e especiais

## **2 NaN (Not a Number)**

### Um **NaN** é um **NA**, mas o **NA** não é um **NaN**


```r
# criar um vetor
ve &lt;- c(1, 2, 3, NA, NaN)
ve
```
--

```r
# verificar a presenca de na
is.na(ve)
```
--

```r
# verificar a presenca de nan
is.nan(ve)
```

---

# 3.6 Valores faltantes e especiais

## **3 Inf (Infinito)**

### É um número muito grande ou um limite matemático, e.g., 10^310 e 1/0

```r
# limite matematico
1/0

# numero grande
10^310
```

---

# 3.6 Valores faltantes e especiais

## **4 NULL**

### Representa um objeto nulo

### Útil para preenchimento de laços e outras aplicações de programação


```r
# objeto nulo
nulo &lt;- NULL
nulo
```

---

# 3.7 Diretório de trabalho

## Endereço da pasta onde o R irá **importar e exportar** os dados

**Atalho**: `ctrl + shift + H`

### **Windows: inverter as barras ("\" por "/")!**


```r
## diretorio de trabalho
# pasta onde o r ira importar e exportar os arquivos

# definir o diretorio de trabalho
setwd("/home/mude/data/github/disciplina-analise-geoespacial/03_dados/tabelas")
```
--

```r
# verificar o diretorio
getwd()
```
--

```r
# verificar os arquivos
dir()
```

---

class: inverse, center, middle

# Vamos trabalhar com dados reais?

---

class: clear, inverse
background-image: url(img/general_real_data.jpg)
background-size: 500px

---

background-image: url(img/general_data_eu_mesmo.png)
background-size: 700px
background-position: 50% 85%

# 3.8 Importar dados

## ATLANTIC AMPHIBIANS: a dataset of amphibian communities from the Atlantic Forests of South America

### Eu mesmo et al. (2018)

---

background-image: url(img/general_bloco_notas.png),url(img/general_planilha.png)
background-size: 200px,200px
background-position: 40% 40%,80% 90%

# 3.8 Importar dados

## Os arquivos de tabelas geralmente estão num desses **três** formatos:

&lt;br&gt;&lt;br&gt;

## 1. csv
## 2. txt
## 3. xlsx

---

# 3.8 Importar dados

## Ler uma planilha eletrônica (.csv)

```r
# ler uma planilha eletronica (.csv)
read.csv("ATLANTIC_AMPHIBIANS_sites.csv")
```

---

# 3.8 Importar dados

## Ler e atribuir uma planilha eletrônica (.csv) a um objeto


```r
# ler e atribuir uma planilha eletronica (.csv) a um objeto
da &lt;- read.csv("ATLANTIC_AMPHIBIANS_sites.csv")
```
--

```r
# ver os dados
da
```
--

```r
# conferir a classe
class(da)
```

---

class: inverse, center, middle

# IMPORTANTE: a tabela importada para o R sempre será um **data frame**!

---

# 3.8 Importar dados

## Ler e atribuir uma planilha simples (.txt) a um objeto

--


```r
# ler e atribuir uma planilha simples (.txt) a um objeto
da &lt;- read.table("ATLANTIC_AMPHIBIANS_sites.txt", header = TRUE, sep = "\t")
da
```

---

# 3.8 Importar dados

## Ler e atribuir uma planilha eletrônica (.xlsx) a um objeto

### Pacote **openxlsx**

```r
# pacote openxlsx
# install.packages("openxlsx")
library(openxlsx)
```

--

### Importar os dados

```r
# ler e atribuir uma planilha eletrônica (.xlsx) a um objeto
da &lt;- openxlsx::read.xlsx("ATLANTIC_AMPHIBIANS_sites.xlsx", sheet = 1)
da
```

---

# 3.9 Conferir e manejar dados

## Conjunto de funções para conferir os dados

&lt;br&gt;&lt;br&gt;

**head()**: mostra as primeiras 6 linhas&lt;br&gt;
**tail()**: mostra as últimas 6 linhas&lt;br&gt;
**nrow()**: mostra o número de linhas&lt;br&gt;
**ncol()**: mostra o número de colunas&lt;br&gt;
**dim()**: mostra o número de linhas e de colunas&lt;br&gt;
**rownames()**: mostra os nomes das linhas (locais)&lt;br&gt;
**colnames()**: mostra os nomes das colunas (variáveis)&lt;br&gt;
**str()**: mostra as classes de cada coluna (estrutura)&lt;br&gt;
**summary()**: mostra um resumo dos valores de cada coluna

---

# 3.9 Conferir e manejar dados

## **head()**: mostra as primeiras 6 linhas



```r
head(da)
```

---

# 3.9 Conferir e manejar dados

## **head()**: mostra as primeiras 10 linhas

```r
head(da, 10)
```

---

# 3.9 Conferir e manejar dados

## **tail()**: mostra as últimas 6 linhas

```r
tail(da)
```

---

# 3.9 Conferir e manejar dados

## **nrow()**: mostra o número de linhas

```r
nrow(da)
```

--

## **ncol()**: mostra o número de colunas

```r
ncol(da)
```

--

## **dim()**: mostra o número de linhas e de colunas

```r
dim(da)
```

---

# 3.9 Conferir e manejar dados

## **rownames()**: mostra os nomes das linhas (locais)

```r
rownames(da)
```

---

# 3.9 Conferir e manejar dados

## **colnames()**: mostra os nomes das colunas (variáveis)

```r
colnames(da)
```

---

# 3.9 Conferir e manejar dados

## **str()**: mostra as classes de cada coluna (estrutura)

```r
str(da)
```

---

# 3.9 Conferir e manejar dados

## **summary()**: mostra um resumo dos valores de cada coluna

```r
summary(da)
```

---

# 3.9 Conferir e manejar dados

## Verificar a presença de NAs

```r
# algum?
any(is.na(da))
```
--

```r
# quais?
which(is.na(da))
```

---

# 3.9 Conferir e manejar dados

## Retirar os NAs

```r
da_na &lt;- na.omit(da)
```
--

```r
nrow(da)
```
--

```r
nrow(da_na)
```

---

# 3.9 Conferir e manejar dados

## Subset das linhas

```r
# subset das linhas com amostragens em sao paulo
da_sp &lt;- da[da$state == "São Paulo", ]
da_sp
```

---

# 3.10 Exportar dados

## Exportar uma tabela de dados na pasta do diretório

--

### Planilha eletrônica (.csv)

```r
write.csv(da_sp, "ATLANTIC_AMPHIBIAN_sites_sao_paulo.csv", 
          row.names = FALSE, quote = FALSE)
```

--

### Planilha de texto (.txt)

```r
write.table(da_sp, "ATLANTIC_AMPHIBIAN_sites_sao_paulo.txt", 
            row.names = FALSE, quote = FALSE)
```

--

### Planilha eletrônica (.xlsx)

```r
openxlsx::write.xlsx(da_sp, "ATLANTIC_AMPHIBIAN_sites_sao_paulo.xlsx", 
                     row.names = FALSE, quote = FALSE)
```

---

class: inverse, center, middle

# Dúvidas?

---

class: clear, middle

&lt;br&gt;&lt;br&gt;&lt;br&gt;

## Maurício Vancine

&lt;br&gt;

Contatos:

<i class="fas  fa-envelope " style="color:#0000ee;"></i> [mauricio.vancine@gmail.com]()
&lt;br&gt;
<i class="fab  fa-twitter " style="color:#0000ee;"></i> [@mauriciovancine](https://twitter.com/mauriciovancine)
&lt;br&gt;
<i class="fab  fa-github " style="color:#0000ee;"></i> [mauriciovancine](https://mauriciovancine.netlify.com/)
&lt;br&gt;
<i class="fas  fa-link " style="color:#0000ee;"></i> [mauriciovancine.netlify.com](https://mauriciovancine.netlify.com/)

&lt;br&gt;&lt;br&gt;&lt;br&gt;

Slides criados via pacote [xaringan](https://github.com/yihui/xaringan) e tema [Metropolis](https://github.com/pat-s/xaringan-metropolis)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "rainbow",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
